<!doctype html>
<html>
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Ether: Monad Transformers and Classes</title>
        <link href='https://fonts.googleapis.com/css?family=Ubuntu+Mono|Ubuntu&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
        <style>
html, body {
    margin: 0;
    padding: 0;
}
a {
    color: inherit;
}
a:hover {
    color: #0a9bf0;
}
body {
    font-family: 'Ubuntu', sans-serif;
    font-size: 20px;
    color: #444;
    margin-left: 1em;
    margin-right: 1em;
}
pre, code {
    font-family: 'Ubuntu Mono', monospace;
    font-size: 0.9em;
}
h1 {
    font-size: 1.5em;
    margin-top: 2em;
}
section {
    display: block;
    padding: 0;
    margin: 0;
}
.section {
    display: block;
    margin: 0 auto;
    max-width: 50em;
}
section:first-child {
    font-size: 6em;
    display: -webkit-box;
    display: -webkit-flex;
    display: -ms-flexbox;
    display: flex;
    -webkit-flex-flow: column;
        -ms-flex-flow: column;
            flex-flow: column;
    -webkit-justify-content: space-around;
        -ms-flex-pack: distribute;
            justify-content: space-around;
    -webkit-box-align: center;
    -webkit-align-items: center;
        -ms-flex-align: center;
            align-items: center;
    color: #0a9bf0;
    margin-top: 1em;
    margin-bottom: 1em;
}
section:first-child h1 {
    text-align: center;
    margin: 0;
}
section:first-child h2 {
    text-align: center;
    font-size: 0.4em;
}
li {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
}
blockquote, .source {
    border-left: 2px solid #0a9bf0;
    padding-left: 2em;
    padding-right: 2em;
    margin-left: 2em;
}
body > footer {
    padding: 1em;
    text-align: center;
}
.hint::before { content: '[' }
.hint::after  { content: ']' }
.hint {
    color: #999;
}
.source {
    display: table;
    border-color: #eee;
}

#forkongithub a {
  background: #0a9bf0;
  color: white;
  text-decoration: none;
  text-align: center;
  font-weight: bold;
  padding: 5px 40px;
  font-size: 16px;
  font-size: 1rem;
  line-height: 32px;
  line-height: 2rem;
  width: 200px;
  position: absolute;
  top: 60px;
  right:-60px;
  -webkit-transform:rotate(45deg);
      -ms-transform:rotate(45deg);
          transform:rotate(45deg);
}
#forkongithub a:before,
#forkongithub a:after {
  content: "";
  width: 100%;
  display: block;
  position: absolute;
  top: 1px;
  left: 0;
  height: 1px;
  background: #0a9bf0;
}
#forkongithub a:after {
  bottom: 1px;
  top: auto;
}
#forkongithub {
  position: absolute;
  display: block;
  top: 0;
  right: 0;
  width: 200px;
  overflow: hidden;
  height: 200px;
  z-index: 9999;
}

@media screen and (max-width:1030px) {
    section:first-child {
        font-size: 4em;
    }
    #forkongithub {
      display: none;
    }
    h1 {
      font-size: 1.3em;
    }
    body {
      font-size: 0.9em;
    }
}

        </style>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/color-brewer.min.css">
        <script src="./vendor/highlight.js/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body>

      <span id="forkongithub">
        <a href="https://github.com/int-index/ether">Source on GitHub</a>
      </span>

      <main>
        <section>
            <h1>Ether</h1>
            <h2>Monad&nbsp;Transformers and&nbsp;Classes</h2>
        </section>
        <section>
        <div class="section">
            <h1>In Short</h1>
            <p>
              Ether is a Haskell library that extends <a href='https://hackage.haskell.org/package/mtl'>mtl</a> and <a href='https://hackage.haskell.org/package/transformers'>transformers</a> with tagged monad transformers and classes. Here are some resources to learn about the concept:
            <ul>
              <li>Blog post <a href='http://blog.sigfpe.com/2010/02/tagging-monad-transformer-layers.html'>Tagging Monad Transformer Layers</a> by Dan Piponi</li>
              <li>Paper <span class="hint">PDF</span> <a href='http://muddsnyder.com/pubs/monadfactory.pdf'>Monad Factory: Type-Indexed Monads</a> by Mark Snyder, Perry Alexander</li>
            </ul>
              See also Roman Cheplyaka's blog post <a href='https://ro-che.info/articles/2014-06-11-problem-with-mtl'>The problem with mtl</a>
              to see what exactly is the problem we're solving here.
            </p>
            <h1>Features</h1>
            <ul>
              <li>
                Tagged effects&mdash;now you can have multiple
                <code>MonadState</code>s, <code>MonadReader</code>s,
                <code>MonadWriter</code>s and <code>MonadExcept</code>s in
                your monad transformer stack.
              </li>
              <li>
                Mix tagged and untagged effects with no effort&mdash;regular
                transformers and classes can remain in your monad transformer stack.
              </li>
              <li>
                Turn untagged effects into tagged ones by wrapping them&mdash;no
                need to rewrite functions that use mtl.
              </li>
              <li>
                Different tagging styles (explicit and implicit)&mdash;no
                need to bother with tags if your types are unique.
              </li>
              <li>
                Simulate Java's checked exceptions, only better&mdash;list all
                exceptions your function can throw in its signature and handle
                them one by one.
              </li>
            </ul>
            <h1>The Code</h1>
            <blockquote>
                <p>Talk is cheap. Show me the code.</p>
                <footer>
                &mdash; <cite><a href="https://lkml.org/lkml/2000/8/25/132">Linus Torvalds</a></cite>
                </footer>
            </blockquote>
            <p>
              Ether's interface is similar to mtl's interface, except most
              functions require a tag. So let's create some tags:
<pre class="source"><code class="haskell">data Foo
data Bar</code></pre>
              Any type can serve as a tag. Later we'll see
              how it's used for implicit tagging.
            </p>
            <p>
              But for now let's stick to our newly created tags <code>Foo</code>
              and <code>Bar</code>. We define a function that uses multiple
              <code>MonadReader</code>s (something impossible with mtl):
<pre class="source"><code class="haskell">add :: ( Num a
       , MonadReader Foo a m
       , MonadReader Bar a m
       ) =&gt; m a
add = liftA2 (+) (ask @Foo) (ask @Bar)

n :: Num a =&gt; a
n = runReader @Foo (runReaderT @Bar add 10) 20</code></pre>
              Here we can see that <code>MonadReader</code>, <code>ask</code>,
              <code>runReader</code> and <code>runReaderT</code> are used just
              like the ones from mtl, only with a tag. As you might expect,
              <code>n</code> here equals <code>30</code> (or
              <code>30.0</code>&mdash;the reader environment can be
              polymorphic).
            </p>
            <p>
              Tagged versions of <code>MonadState</code>, <code>MonadWriter</code>
              and <code>MonadExcept</code> are provided as well. There's no
              tagged <code>MonadCont</code> because I couldn't think of a use
              case for multiple <code>MonadCont</code>s in a monad transformer
              stack.
            </p>
            <p>
              Ether's classes are fully compatible with ones from mtl,
              meaning that you can use Ether with your existing code without
              unnecessary changes. Consider the following code snippet:
<pre class="source"><code class="haskell">summator
    :: ( Num a
       , MonadWriter (Sum a) m
       ) =&gt; [a] -&gt; m ()
summator xs = do
    for_ xs $ \x -&gt; tell (Sum x)</code></pre>
              Now, say you want to add another <code>MonadWriter</code> to count
              how many numbers you've summed up. As we know, it's impossible
              with mtl alone, but you can combine the existing untagged
              <code>MonadWriter</code> with a tagged one:
<pre class="source"><code class="haskell">import qualified Control.Monad.Ether.Writer as Ether

summator
    :: ( Num a
       , MonadWriter (Sum a) m
       , Ether.MonadWriter Foo (Sum a) m
       ) =&gt; [a] -&gt; m ()
summator xs = do
    for_ xs $ \x -&gt; do
        tell (Sum x)
        Ether.tell @Foo (Sum 1)</code></pre>
              Easy, right? Untagged classes can be considered a special case of
              tagged ones, and any mix of them should Just Work&trade;. But
              wait, there's more...
            </p>
            <p>
              What if you have two functions, both requiring a <code>MonadState</code>,
              but it's different <code>MonadState</code>s? There's no way you could
              use those functions in one monad transformer stack with mtl, thus
              <em>mtl is antimodular!</em>
              However, Ether comes to the rescue with its wrapping mechanism:
<pre class="source"><code class="haskell">f :: MonadState Int m =&gt; m String
f = <em>omitted</em>

g :: MonadState Bool m =&gt; m String
g = <em>omitted</em>

useboth
    :: ( Ether.MonadState Foo Int  m
       , Ether.MonadState Bar Bool m
       ) =&gt; m String
useboth = do
    a &lt;- tagAttach @Foo f
    b &lt;- tagAttach @Bar g
    return (a ++ b)
</code></pre>
              Here we use the <code>tagAttach</code> function
              from <code>Control.Monad.Trans.Ether.Dispatch</code>
              to turn untagged transformers into tagged ones.
            </p>
            <p>
              On this wave of modularity features I'd like to present you another
              one: simulating checked exceptions from Java. It's as simple as
              having one <code>MonadExcept</code> per exception:
<pre class="source"><code class="haskell">data DivideByZero = DivideByZero
data NegativeLog = NegativeLog

logDiv
    ( Floating a
    , Ord a
    , MonadExcept Foo DivideByZero m
    , MonadExcept Bar NegativeLog  m
    ) =&gt; a -&gt; a -&gt; m a
logDiv x y = do
    when (y == 0) (throw @Foo DivideByZero)
    let d = x/y
    when (d &lt; 0) (throw @Bar NegativeLog)
    return (log d)</code></pre>
              Now we can handle those exceptions one by one with <code>runExceptT</code>.
              However, this tagging business starts to become unmanagable. Do we
              also need to create a tag per exception? The answer, fortunately,
              is no: since exceptions tend to be monomorphic, we can use them
              as tags for their classes. This feature is called implicit
              tagging, and we can rewrite the example above like so:
<pre class="source"><code class="haskell">import qualified Control.Monad.Ether.Implicit.Except as I

logDiv
    ( Floating a
    , Ord a
    , I.MonadExcept DivideByZero m
    , I.MonadExcept NegativeLog  m
    ) =&gt; a -&gt; a -&gt; m a
logDiv x y = do
    when (y == 0) (I.throw DivideByZero)
    let d = x/y
    when (d &lt; 0) (I.throw NegativeLog)
    return (log d)
</code></pre>
            That's better. In fact, implicit tagging can be used with polymorphic
            tags too, but its behavior can be sometimes unobvious. You also may
            need to use type annotations when using implicit tagging, so for
            anything polymorphic prefer the explicit style.
            </p>
        </div>
        </section>
      </main>
      <footer>
        <a href="https://github.com/int-index">Vladislav Zavialov</a>, 2017
      </footer>
    </body>
</html>
